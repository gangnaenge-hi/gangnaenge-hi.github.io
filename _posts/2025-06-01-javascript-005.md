---
title: 동작 방식
description: >-
author: yell
date: 2025-06-01 20:55:00 +0800
categories: [Blogging, Javascript]
tags: [Javascript]
---

### JavaScript 엔진과 동작 방식

엔진은 브라우저마다 다름(Chrome - V8, FireFox - Spider Monkey)

이 엔진이 Parsing & Execution 하는데 크게 인터프리터와 컴파일러로 나뉨

![image.png](/assets/img/category/js/img_005_01.png)

1. 파싱 → AST 생성 (추상 구문 트리, Abstract Syntax Tree)
2. 바이트코드 생성
3. 인터프리터가 바이트코드 실행(빠른 시작) → 여기까지 인터프리터
4. 핫 코드를 JIT 컴파일해서 머신 코드로 최적화

[JavaScript V8 Engine Explained | HackerNoon](https://hackernoon.com/javascript-v8-engine-explained-3f940148d4ef)

### 코드 실행의 원리

![image.png](/assets/img/category/js/img_005_02.png)

JavaScript 엔진은 코드를 실행하는 주체로서 메모리와 실행 단계에 대한 관리가 이루어짐

- Heap
    - 장기 메모리, 시스템 메모리 데이터 저장
- Stack
    - 단기 메모리, 현재 실행되고 있는 함수를 관리
    - → Execution Context
    - 한번에 하나의 작업만 수행, 함수의 실행 순서 보장
    - → 단일 스레드의 원리

🧚 coming soon Event Loop

푸시된 이벤트가 실행 중인 스크립트를 방해하지 않고 Call Stack 이 빈 상태가 되면 순서에 맞게 실행되도록 제어

### 원시 vs 참조 값

![image.png](/assets/img/category/js/img_005_03.png)

- 원시값
    - String, Numbers, Booleans, null, undefined, Symbol
    - 적은 메모리, 일반적으로 스택 메모리에 저장
    - 실제 값을 저장 → 복사 시 값이 복사되어 저장
- 참조값
    - 모든 객체
    - 내장 함수, 더 많은 데이터, 관리가 복잡 → 보통 힙에 저장
    - 포인터만 저장, 값 자체가 아닌 메모리 공간의 주소
    - → 복사 시 포인터만을 복사하여 저장
    - 이는 데이터의 불필요한 복제를 피하고 메모리가 차는 것을 방지하여 더 나은 성능을 제공하기 위함
    - 복사된 데이터만 편집하고 싶을 때 깊은 복사를 이용한 방안 활용 (Spread Operator 등)
    - `const` 일 때 `push()`나 property 의 변경은(`person.age = 21`) 데이터의 변경이기 때문에 가능하지만
    - 연산자 할당은(`person = { age: 22 }`) 새로운 객체를 설정하는 것(=주소의 변경) 이기 때문에 불가능하다.

### Garbage Collection

사용되지 않은 객체 대한 힙 메모리를 주기적으로 확인하여 제거하는 역할

null 로 설정한다고 즉각적으로 제거되는 것은 아님

자체 스케줄에 따라서 확인하여 제거되는 것

### 메모리 누수

더는 동작하지 않는 객체를 참조하고 있을 때는 가비지 컬렉션이 동작하지 않음 → 에러

**익명함수와 이벤트 리스너**

```jsx
function printMessage() {
  const value = messageInput.value;
  console.log(value || 'Clicked me!');
}

// addListenerBtn.addEventListener()를 실행 수와 상관 없음
function addListener() {
  clickableBtn.addEventListener('click', printMessage);
}
// addListenerBtn.addEventListener()를 실행한 만큼 익명함수가 실행됨 
// 새로운 객체로 인식되기 때문
function addListener() {
  clickableBtn.addEventListener('click', function() {
    const value = messageInput.value;
    console.log(value || 'Clicked me!');
  });
}

addListenerBtn.addEventListener('click', addListener);
```
